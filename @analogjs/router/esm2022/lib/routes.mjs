/// <reference types="vite/client" />
import { toRouteConfig } from './route-config';
import { toMarkdownModule } from './markdown-helpers';
import { APP_DIR, ENDPOINT_EXTENSION } from './constants';
import { ANALOG_META_KEY } from './endpoints';
const FILES = import.meta.glob([
    '/app/routes/**/*.ts',
    '/src/app/routes/**/*.ts',
    '/src/app/pages/**/*.page.ts',
]);
const CONTENT_FILES = import.meta.glob(['/src/app/routes/**/*.md', '/src/app/pages/**/*.md'], { as: 'raw' });
/**
 * A function used to parse list of files and create configuration of routes.
 *
 * @param files
 * @returns Array of routes
 */
export function createRoutes(files) {
    const filenames = Object.keys(files);
    if (filenames.length === 0) {
        return [];
    }
    // map filenames to raw routes and group them by level
    const rawRoutesByLevelMap = filenames.reduce((acc, filename) => {
        const rawPath = toRawPath(filename);
        const rawSegments = rawPath.split('/');
        // nesting level starts at 0
        // rawPath: /products => level: 0
        // rawPath: /products/:id => level: 1
        const level = rawSegments.length - 1;
        const rawSegment = rawSegments[level];
        const ancestorRawSegments = rawSegments.slice(0, level);
        return {
            ...acc,
            [level]: {
                ...acc[level],
                [rawPath]: {
                    filename,
                    rawSegment,
                    ancestorRawSegments,
                    segment: toSegment(rawSegment),
                    level,
                    children: [],
                },
            },
        };
    }, {});
    const allLevels = Object.keys(rawRoutesByLevelMap).map(Number);
    const maxLevel = Math.max(...allLevels);
    // add each raw route to its parent's children array
    for (let level = maxLevel; level > 0; level--) {
        const rawRoutesMap = rawRoutesByLevelMap[level];
        const rawPaths = Object.keys(rawRoutesMap);
        for (const rawPath of rawPaths) {
            const rawRoute = rawRoutesMap[rawPath];
            const parentRawPath = rawRoute.ancestorRawSegments.join('/');
            const parentRawSegmentIndex = rawRoute.ancestorRawSegments.length - 1;
            const parentRawSegment = rawRoute.ancestorRawSegments[parentRawSegmentIndex];
            // create the parent level and/or raw route if it does not exist
            // parent route won't exist for nested routes that don't have a layout route
            rawRoutesByLevelMap[level - 1] ||= {};
            rawRoutesByLevelMap[level - 1][parentRawPath] ||= {
                filename: null,
                rawSegment: parentRawSegment,
                ancestorRawSegments: rawRoute.ancestorRawSegments.slice(0, parentRawSegmentIndex),
                segment: toSegment(parentRawSegment),
                level: level - 1,
                children: [],
            };
            rawRoutesByLevelMap[level - 1][parentRawPath].children.push(rawRoute);
        }
    }
    // only take raw routes from the root level
    // since they already contain nested routes as their children
    const rootRawRoutesMap = rawRoutesByLevelMap[0];
    const rawRoutes = Object.keys(rootRawRoutesMap).map((segment) => rootRawRoutesMap[segment]);
    sortRawRoutes(rawRoutes);
    return toRoutes(rawRoutes, files);
}
function toRawPath(filename) {
    return filename
        .replace(
    // convert to relative path and remove file extension
    /^\/(.*?)\/routes\/|^\/(.*?)\/pages\/|\/app\/routes\/|(\.page\.(js|ts)$)|(\.(ts|md)$)/g, '')
        .replace(/\[\.{3}.+\]/, '**') // [...not-found] => **
        .replace(/\[([^\]]+)\]/g, ':$1'); // [id] => :id
}
function toSegment(rawSegment) {
    return rawSegment
        .replace(/index|\(.*?\)/g, '') // replace named empty segments
        .replace(/\.|\/+/g, '/') // replace dots with slashes and remove redundant slashes
        .replace(/^\/+|\/+$/g, ''); // remove trailing slashes
}
function toRoutes(rawRoutes, files) {
    const routes = [];
    for (const rawRoute of rawRoutes) {
        const children = rawRoute.children.length > 0
            ? toRoutes(rawRoute.children, files)
            : undefined;
        let module = undefined;
        let analogMeta = undefined;
        if (rawRoute.filename) {
            const isMarkdownFile = rawRoute.filename.endsWith('.md');
            module = isMarkdownFile
                ? toMarkdownModule(files[rawRoute.filename])
                : files[rawRoute.filename];
            const endpointKey = rawRoute.filename.replace(/\.page\.ts$/, ENDPOINT_EXTENSION);
            // get endpoint path
            const rawEndpoint = rawRoute.filename
                .replace(/\.page\.ts$/, '')
                .replace(/\[\.{3}.+\]/, '**') // [...not-found] => **
                .split(APP_DIR)[1];
            // replace periods, remove (index) paths
            const endpoint = (rawEndpoint || '')
                .replace(/\./g, '/')
                .replace(/\/\((.*?)\)$/, '/-$1-');
            analogMeta = {
                endpoint,
                endpointKey,
            };
        }
        const route = module
            ? {
                path: rawRoute.segment,
                loadChildren: () => module().then((m) => [
                    {
                        path: '',
                        component: m.default,
                        ...toRouteConfig(m.routeMeta),
                        children,
                        [ANALOG_META_KEY]: analogMeta,
                    },
                ]),
            }
            : { path: rawRoute.segment, children };
        routes.push(route);
    }
    return routes;
}
function sortRawRoutes(rawRoutes) {
    rawRoutes.sort((a, b) => {
        let segmentA = deprioritizeSegment(a.segment);
        let segmentB = deprioritizeSegment(b.segment);
        // prioritize routes with fewer children
        if (a.children.length > b.children.length) {
            segmentA = `~${segmentA}`;
        }
        else if (a.children.length < b.children.length) {
            segmentB = `~${segmentB}`;
        }
        return segmentA > segmentB ? 1 : -1;
    });
    for (const rawRoute of rawRoutes) {
        sortRawRoutes(rawRoute.children);
    }
}
function deprioritizeSegment(segment) {
    // deprioritize param and wildcard segments
    return segment.replace(':', '~~').replace('**', '~~~~');
}
export const routes = createRoutes({ ...FILES, ...CONTENT_FILES });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvcm91dGVyL3NyYy9saWIvcm91dGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHFDQUFxQztBQUtyQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDL0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDdEQsT0FBTyxFQUFFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUMxRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRTlDLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFjO0lBQzFDLHFCQUFxQjtJQUNyQix5QkFBeUI7SUFDekIsNkJBQTZCO0NBQzlCLENBQUMsQ0FBQztBQUVILE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUNwQyxDQUFDLHlCQUF5QixFQUFFLHdCQUF3QixDQUFDLEVBQ3JELEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxDQUNkLENBQUM7QUFpQkY7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsWUFBWSxDQUFDLEtBQVk7SUFDdkMsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUVyQyxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQzFCLE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFFRCxzREFBc0Q7SUFDdEQsTUFBTSxtQkFBbUIsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLFFBQVEsRUFBRSxFQUFFO1FBQzdELE1BQU0sT0FBTyxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNwQyxNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcs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QUFZLENBQUMsRUFBRSxHQUFHLEtBQUssRUFBRSxHQUFHLGFBQWEsRUFBRSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cInZpdGUvY2xpZW50XCIgLz5cblxuaW1wb3J0IHR5cGUgeyBSb3V0ZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5cbmltcG9ydCB0eXBlIHsgUm91dGVFeHBvcnQsIFJvdXRlTWV0YSB9IGZyb20gJy4vbW9kZWxzJztcbmltcG9ydCB7IHRvUm91dGVDb25maWcgfSBmcm9tICcuL3JvdXRlLWNvbmZpZyc7XG5pbXBvcnQgeyB0b01hcmtkb3duTW9kdWxlIH0gZnJvbSAnLi9tYXJrZG93bi1oZWxwZXJzJztcbmltcG9ydCB7IEFQUF9ESVIsIEVORFBPSU5UX0VYVEVOU0lPTiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IEFOQUxPR19NRVRBX0tFWSB9IGZyb20gJy4vZW5kcG9pbnRzJztcblxuY29uc3QgRklMRVMgPSBpbXBvcnQubWV0YS5nbG9iPFJvdXRlRXhwb3J0PihbXG4gICcvYXBwL3JvdXRlcy8qKi8qLnRzJyxcbiAgJy9zcmMvYXBwL3JvdXRlcy8qKi8qLnRzJyxcbiAgJy9zcmMvYXBwL3BhZ2VzLyoqLyoucGFnZS50cycsXG5dKTtcblxuY29uc3QgQ09OVEVOVF9GSUxFUyA9IGltcG9ydC5tZXRhLmdsb2I8c3RyaW5nPihcbiAgWycvc3JjL2FwcC9yb3V0ZXMvKiovKi5tZCcsICcvc3JjL2FwcC9wYWdlcy8qKi8qLm1kJ10sXG4gIHsgYXM6ICdyYXcnIH1cbik7XG5cbmV4cG9ydCB0eXBlIEZpbGVzID0gUmVjb3JkPHN0cmluZywgKCkgPT4gUHJvbWlzZTxSb3V0ZUV4cG9ydCB8IHN0cmluZz4+O1xuXG50eXBlIFJhd1JvdXRlID0ge1xuICBmaWxlbmFtZTogc3RyaW5nIHwgbnVsbDtcbiAgcmF3U2VnbWVudDogc3RyaW5nO1xuICBhbmNlc3RvclJhd1NlZ21lbnRzOiBzdHJpbmdbXTtcbiAgc2VnbWVudDogc3RyaW5nO1xuICBsZXZlbDogbnVtYmVyO1xuICBjaGlsZHJlbjogUmF3Um91dGVbXTtcbn07XG5cbnR5cGUgUmF3Um91dGVNYXAgPSBSZWNvcmQ8c3RyaW5nLCBSYXdSb3V0ZT47XG5cbnR5cGUgUmF3Um91dGVCeUxldmVsTWFwID0gUmVjb3JkPG51bWJlciwgUmF3Um91dGVNYXA+O1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdXNlZCB0byBwYXJzZSBsaXN0IG9mIGZpbGVzIGFuZCBjcmVhdGUgY29uZmlndXJhdGlvbiBvZiByb3V0ZXMuXG4gKlxuICogQHBhcmFtIGZpbGVzXG4gKiBAcmV0dXJucyBBcnJheSBvZiByb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlcyhmaWxlczogRmlsZXMpOiBSb3V0ZVtdIHtcbiAgY29uc3QgZmlsZW5hbWVzID0gT2JqZWN0LmtleXMoZmlsZXMpO1xuXG4gIGlmIChmaWxlbmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gbWFwIGZpbGVuYW1lcyB0byByYXcgcm91dGVzIGFuZCBncm91cCB0aGVtIGJ5IGxldmVsXG4gIGNvbnN0IHJhd1JvdXRlc0J5TGV2ZWxNYXAgPSBmaWxlbmFtZXMucmVkdWNlKChhY2MsIGZpbGVuYW1lKSA9PiB7XG4gICAgY29uc3QgcmF3UGF0aCA9IHRvUmF3UGF0aChmaWxlbmFtZSk7XG4gICAgY29uc3QgcmF3U2VnbWVudHMgPSByYXdQYXRoLnNwbGl0KCcvJyk7XG4gICAgLy8gbmVzdGluZyBsZXZlbCBzdGFydHMgYXQgMFxuICAgIC8vIHJhd1BhdGg6IC9wcm9kdWN0cyA9PiBsZXZlbDogMFxuICAgIC8vIHJhd1BhdGg6IC9wcm9kdWN0cy86aWQgPT4gbGV2ZWw6IDFcbiAgICBjb25zdCBsZXZlbCA9IHJhd1NlZ21lbnRzLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgcmF3U2VnbWVudCA9IHJhd1NlZ21lbnRzW2xldmVsXTtcbiAgICBjb25zdCBhbmNlc3RvclJhd1NlZ21lbnRzID0gcmF3U2VnbWVudHMuc2xpY2UoMCwgbGV2ZWwpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFjYyxcbiAgICAgIFtsZXZlbF06IHtcbiAgICAgICAgLi4uYWNjW2xldmVsXSxcbiAgICAgICAgW3Jhd1BhdGhdOiB7XG4gICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgcmF3U2VnbWVudCxcbiAgICAgICAgICBhbmNlc3RvclJhd1NlZ21lbnRzLFxuICAgICAgICAgIHNlZ21lbnQ6IHRvU2VnbWVudChyYXdTZWdtZW50KSxcbiAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gIH0sIHt9IGFzIFJhd1JvdXRlQnlMZXZlbE1hcCk7XG5cbiAgY29uc3QgYWxsTGV2ZWxzID0gT2JqZWN0LmtleXMocmF3Um91dGVzQnlMZXZlbE1hcCkubWFwKE51bWJlcik7XG4gIGNvbnN0IG1heExldmVsID0gTWF0aC5tYXgoLi4uYWxsTGV2ZWxzKTtcblxuICAvLyBhZGQgZWFjaCByYXcgcm91dGUgdG8gaXRzIHBhcmVudCdzIGNoaWxkcmVuIGFycmF5XG4gIGZvciAobGV0IGxldmVsID0gbWF4TGV2ZWw7IGxldmVsID4gMDsgbGV2ZWwtLSkge1xuICAgIGNvbnN0IHJhd1JvdXRlc01hcCA9IHJhd1JvdXRlc0J5TGV2ZWxNYXBbbGV2ZWxdO1xuICAgIGNvbnN0IHJhd1BhdGhzID0gT2JqZWN0LmtleXMocmF3Um91dGVzTWFwKTtcblxuICAgIGZvciAoY29uc3QgcmF3UGF0aCBvZiByYXdQYXRocykge1xuICAgICAgY29uc3QgcmF3Um91dGUgPSByYXdSb3V0ZXNNYXBbcmF3UGF0aF07XG4gICAgICBjb25zdCBwYXJlbnRSYXdQYXRoID0gcmF3Um91dGUuYW5jZXN0b3JSYXdTZWdtZW50cy5qb2luKCcvJyk7XG4gICAgICBjb25zdCBwYXJlbnRSYXdTZWdtZW50SW5kZXggPSByYXdSb3V0ZS5hbmNlc3RvclJhd1NlZ21lbnRzLmxlbmd0aCAtIDE7XG4gICAgICBjb25zdCBwYXJlbnRSYXdTZWdtZW50ID1cbiAgICAgICAgcmF3Um91dGUuYW5jZXN0b3JSYXdTZWdtZW50c1twYXJlbnRSYXdTZWdtZW50SW5kZXhdO1xuXG4gICAgICAvLyBjcmVhdGUgdGhlIHBhcmVudCBsZXZlbCBhbmQvb3IgcmF3IHJvdXRlIGlmIGl0IGRvZXMgbm90IGV4aXN0XG4gICAgICAvLyBwYXJlbnQgcm91dGUgd29uJ3QgZXhpc3QgZm9yIG5lc3RlZCByb3V0ZXMgdGhhdCBkb24ndCBoYXZlIGEgbGF5b3V0IHJvdXRlXG4gICAgICByYXdSb3V0ZXNCeUxldmVsTWFwW2xldmVsIC0gMV0gfHw9IHt9O1xuICAgICAgcmF3Um91dGVzQnlMZXZlbE1hcFtsZXZlbCAtIDFdW3BhcmVudFJhd1BhdGhdIHx8PSB7XG4gICAgICAgIGZpbGVuYW1lOiBudWxsLFxuICAgICAgICByYXdTZWdtZW50OiBwYXJlbnRSYXdTZWdtZW50LFxuICAgICAgICBhbmNlc3RvclJhd1NlZ21lbnRzOiByYXdSb3V0ZS5hbmNlc3RvclJhd1NlZ21lbnRzLnNsaWNlKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgcGFyZW50UmF3U2VnbWVudEluZGV4XG4gICAgICAgICksXG4gICAgICAgIHNlZ21lbnQ6IHRvU2VnbWVudChwYXJlbnRSYXdTZWdtZW50KSxcbiAgICAgICAgbGV2ZWw6IGxldmVsIC0gMSxcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgfTtcblxuICAgICAgcmF3Um91dGVzQnlMZXZlbE1hcFtsZXZlbCAtIDFdW3BhcmVudFJhd1BhdGhdLmNoaWxkcmVuLnB1c2gocmF3Um91dGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG9ubHkgdGFrZSByYXcgcm91dGVzIGZyb20gdGhlIHJvb3QgbGV2ZWxcbiAgLy8gc2luY2UgdGhleSBhbHJlYWR5IGNvbnRhaW4gbmVzdGVkIHJvdXRlcyBhcyB0aGVpciBjaGlsZHJlblxuICBjb25zdCByb290UmF3Um91dGVzTWFwID0gcmF3Um91dGVzQnlMZXZlbE1hcFswXTtcbiAgY29uc3QgcmF3Um91dGVzID0gT2JqZWN0LmtleXMocm9vdFJhd1JvdXRlc01hcCkubWFwKFxuICAgIChzZWdtZW50KSA9PiByb290UmF3Um91dGVzTWFwW3NlZ21lbnRdXG4gICk7XG4gIHNvcnRSYXdSb3V0ZXMocmF3Um91dGVzKTtcblxuICByZXR1cm4gdG9Sb3V0ZXMocmF3Um91dGVzLCBmaWxlcyk7XG59XG5cbmZ1bmN0aW9uIHRvUmF3UGF0aChmaWxlbmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGZpbGVuYW1lXG4gICAgLnJlcGxhY2UoXG4gICAgICAvLyBjb252ZXJ0IHRvIHJlbGF0aXZlIHBhdGggYW5kIHJlbW92ZSBmaWxlIGV4dGVuc2lvblxuICAgICAgL15cXC8oLio/KVxcL3JvdXRlc1xcL3xeXFwvKC4qPylcXC9wYWdlc1xcL3xcXC9hcHBcXC9yb3V0ZXNcXC98KFxcLnBhZ2VcXC4oanN8dHMpJCl8KFxcLih0c3xtZCkkKS9nLFxuICAgICAgJydcbiAgICApXG4gICAgLnJlcGxhY2UoL1xcW1xcLnszfS4rXFxdLywgJyoqJykgLy8gWy4uLm5vdC1mb3VuZF0gPT4gKipcbiAgICAucmVwbGFjZSgvXFxbKFteXFxdXSspXFxdL2csICc6JDEnKTsgLy8gW2lkXSA9PiA6aWRcbn1cblxuZnVuY3Rpb24gdG9TZWdtZW50KHJhd1NlZ21lbnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiByYXdTZWdtZW50XG4gICAgLnJlcGxhY2UoL2luZGV4fFxcKC4qP1xcKS9nLCAnJykgLy8gcmVwbGFjZSBuYW1lZCBlbXB0eSBzZWdtZW50c1xuICAgIC5yZXBsYWNlKC9cXC58XFwvKy9nLCAnLycpIC8vIHJlcGxhY2UgZG90cyB3aXRoIHNsYXNoZXMgYW5kIHJlbW92ZSByZWR1bmRhbnQgc2xhc2hlc1xuICAgIC5yZXBsYWNlKC9eXFwvK3xcXC8rJC9nLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaGVzXG59XG5cbmZ1bmN0aW9uIHRvUm91dGVzKHJhd1JvdXRlczogUmF3Um91dGVbXSwgZmlsZXM6IEZpbGVzKTogUm91dGVbXSB7XG4gIGNvbnN0IHJvdXRlczogUm91dGVbXSA9IFtdO1xuXG4gIGZvciAoY29uc3QgcmF3Um91dGUgb2YgcmF3Um91dGVzKSB7XG4gICAgY29uc3QgY2hpbGRyZW46IFJvdXRlW10gfCB1bmRlZmluZWQgPVxuICAgICAgcmF3Um91dGUuY2hpbGRyZW4ubGVuZ3RoID4gMFxuICAgICAgICA/IHRvUm91dGVzKHJhd1JvdXRlLmNoaWxkcmVuLCBmaWxlcylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgbGV0IG1vZHVsZTogKCgpID0+IFByb21pc2U8Um91dGVFeHBvcnQ+KSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgYW5hbG9nTWV0YTogeyBlbmRwb2ludDogc3RyaW5nOyBlbmRwb2ludEtleTogc3RyaW5nIH0gfCB1bmRlZmluZWQgPVxuICAgICAgdW5kZWZpbmVkO1xuXG4gICAgaWYgKHJhd1JvdXRlLmZpbGVuYW1lKSB7XG4gICAgICBjb25zdCBpc01hcmtkb3duRmlsZSA9IHJhd1JvdXRlLmZpbGVuYW1lLmVuZHNXaXRoKCcubWQnKTtcbiAgICAgIG1vZHVsZSA9IGlzTWFya2Rvd25GaWxlXG4gICAgICAgID8gdG9NYXJrZG93bk1vZHVsZShmaWxlc1tyYXdSb3V0ZS5maWxlbmFtZV0gYXMgKCkgPT4gUHJvbWlzZTxzdHJpbmc+KVxuICAgICAgICA6IChmaWxlc1tyYXdSb3V0ZS5maWxlbmFtZV0gYXMgKCkgPT4gUHJvbWlzZTxSb3V0ZUV4cG9ydD4pO1xuXG4gICAgICBjb25zdCBlbmRwb2ludEtleSA9IHJhd1JvdXRlLmZpbGVuYW1lLnJlcGxhY2UoXG4gICAgICAgIC9cXC5wYWdlXFwudHMkLyxcbiAgICAgICAgRU5EUE9JTlRfRVhURU5TSU9OXG4gICAgICApO1xuXG4gICAgICAvLyBnZXQgZW5kcG9pbnQgcGF0aFxuICAgICAgY29uc3QgcmF3RW5kcG9pbnQgPSByYXdSb3V0ZS5maWxlbmFtZVxuICAgICAgICAucmVwbGFjZSgvXFwucGFnZVxcLnRzJC8sICcnKVxuICAgICAgICAucmVwbGFjZSgvXFxbXFwuezN9LitcXF0vLCAnKionKSAvLyBbLi4ubm90LWZvdW5kXSA9PiAqKlxuICAgICAgICAuc3BsaXQoQVBQX0RJUilbMV07XG5cbiAgICAgIC8vIHJlcGxhY2UgcGVyaW9kcywgcmVtb3ZlIChpbmRleCkgcGF0aHNcbiAgICAgIGNvbnN0IGVuZHBvaW50ID0gKHJhd0VuZHBvaW50IHx8ICcnKVxuICAgICAgICAucmVwbGFjZSgvXFwuL2csICcvJylcbiAgICAgICAgLnJlcGxhY2UoL1xcL1xcKCguKj8pXFwpJC8sICcvLSQxLScpO1xuXG4gICAgICBhbmFsb2dNZXRhID0ge1xuICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgZW5kcG9pbnRLZXksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlOiBSb3V0ZSAmIHsgbWV0YT86IHR5cGVvZiBhbmFsb2dNZXRhIH0gPSBtb2R1bGVcbiAgICAgID8ge1xuICAgICAgICAgIHBhdGg6IHJhd1JvdXRlLnNlZ21lbnQsXG4gICAgICAgICAgbG9hZENoaWxkcmVuOiAoKSA9PlxuICAgICAgICAgICAgbW9kdWxlISgpLnRoZW4oKG0pID0+IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBhdGg6ICcnLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogbS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgIC4uLnRvUm91dGVDb25maWcobS5yb3V0ZU1ldGEgYXMgUm91dGVNZXRhIHwgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICBbQU5BTE9HX01FVEFfS0VZXTogYW5hbG9nTWV0YSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICB9XG4gICAgICA6IHsgcGF0aDogcmF3Um91dGUuc2VnbWVudCwgY2hpbGRyZW4gfTtcblxuICAgIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgfVxuXG4gIHJldHVybiByb3V0ZXM7XG59XG5cbmZ1bmN0aW9uIHNvcnRSYXdSb3V0ZXMocmF3Um91dGVzOiBSYXdSb3V0ZVtdKTogdm9pZCB7XG4gIHJhd1JvdXRlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgbGV0IHNlZ21lbnRBID0gZGVwcmlvcml0aXplU2VnbWVudChhLnNlZ21lbnQpO1xuICAgIGxldCBzZWdtZW50QiA9IGRlcHJpb3JpdGl6ZVNlZ21lbnQoYi5zZWdtZW50KTtcblxuICAgIC8vIHByaW9yaXRpemUgcm91dGVzIHdpdGggZmV3ZXIgY2hpbGRyZW5cbiAgICBpZiAoYS5jaGlsZHJlbi5sZW5ndGggPiBiLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgc2VnbWVudEEgPSBgfiR7c2VnbWVudEF9YDtcbiAgICB9IGVsc2UgaWYgKGEuY2hpbGRyZW4ubGVuZ3RoIDwgYi5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHNlZ21lbnRCID0gYH4ke3NlZ21lbnRCfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlZ21lbnRBID4gc2VnbWVudEIgPyAxIDogLTE7XG4gIH0pO1xuXG4gIGZvciAoY29uc3QgcmF3Um91dGUgb2YgcmF3Um91dGVzKSB7XG4gICAgc29ydFJhd1JvdXRlcyhyYXdSb3V0ZS5jaGlsZHJlbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVwcmlvcml0aXplU2VnbWVudChzZWdtZW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBkZXByaW9yaXRpemUgcGFyYW0gYW5kIHdpbGRjYXJkIHNlZ21lbnRzXG4gIHJldHVybiBzZWdtZW50LnJlcGxhY2UoJzonLCAnfn4nKS5yZXBsYWNlKCcqKicsICd+fn5+Jyk7XG59XG5cbmV4cG9ydCBjb25zdCByb3V0ZXM6IFJvdXRlW10gPSBjcmVhdGVSb3V0ZXMoeyAuLi5GSUxFUywgLi4uQ09OVEVOVF9GSUxFUyB9KTtcbiJdfQ==